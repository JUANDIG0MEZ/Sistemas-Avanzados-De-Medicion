import matplotlib.pyplot as plt
import numpy as np
from hardwareInTheLoop import Parametros_2, x1_modelo2, tiempo_2, fuerza_2
from hardwareInTheLoop import Parametros_1, x1_modelo1, tiempo_1, u_1



class KalmanFilter3:
    def __init__(self, F, H, Q, R, P0):
        self.F = F  # Matriz de transición
        self.H = H  # Matriz de medición
        self.Q = Q  # Covarianza del proceso
        self.R = R  # Covarianza del sensor
        self.P = P0  # Covarianza del error
        self.x = np.array([[0.0], [0.0], [0.0]])  # Estado inicial

    def predict(self):
        self.x = self.F @ self.x
        self.P = self.F @ self.P @ self.F.T + self.Q

    def update(self, z):
        K = self.P @ self.H.T @ np.linalg.inv(self.H @ self.P @ self.H.T + self.R)
        self.x += K @ (z - self.H @ self.x)
        self.P = (np.eye(3) - K @ self.H) @ self.P


class KalmanFilter2:
    def __init__(self, F, H, Q, R, P0):
        self.F = F  # Matriz de transición
        self.H = H  # Matriz de medición
        self.Q = Q  # Covarianza del proceso
        self.R = R  # Covarianza del sensor
        self.P = P0  # Covarianza del error
        self.x = np.array([[0.0], [0.0]])  # Estado inicial

    def predict(self):
        self.x = self.F @ self.x
        self.P = self.F @ self.P @ self.F.T + self.Q

    def update(self, z):
        K = self.P @ self.H.T @ np.linalg.inv(self.H @ self.P @ self.H.T + self.R)
        self.x += K @ (z - self.H @ self.x)
        self.P = (np.eye(2) - K @ self.H) @ self.P



def fourier_2(y):
    dt = Parametros_2.dt

    Y = np.fft.fft(y)
    N = len(tiempo_2)

    omega = 2 * np.pi * np.fft.fftfreq(N, dt)
    omega_n = Parametros_2.omega_n
    zeta = Parametros_2.zeta
    k_s = Parametros_2.k_s
    masa = Parametros_2.masa


    F_omega = (masa)/k_s * ((-omega**2 + 2j*zeta*omega_n*omega + omega_n)* Y)

    F = np.fft.ifft(F_omega).real

    return F


def fourier_1(y):
    dt = Parametros_1.dt
    N = len(tiempo_1)


    Y = np.fft.fft(y)
    

    tau = Parametros_1.tau
    k_s = Parametros_1.k_s
    omega = 2 * np.pi * np.fft.fftfreq(N, dt)

    U_omega = (tau * 1j * omega + 1) * Y / k_s

    u = np.fft.ifft(U_omega).real
    return u



class Modelo2:
    # Varianza de la tasa de cambio de la fuerza 
    q_F = 2.0
    # Varianza en las mediciones del sensor
    #r_F = 0.039
    r_F = 0.039

    # Covarianza inicial
    P0 = np.eye(3) * 0.001  


    # Matrices necesarias para kalman
    A = np.array([
        [0, 1, 0],
        [-Parametros_2.omega_n**2, -2*Parametros_2.zeta*Parametros_2.omega_n, Parametros_2.k_s/ Parametros_2.masa],
        [0, 0, 0]
        ])
    F = np.eye(3) + A * Parametros_2.dt
    H = np.array([[1.0, 0.0, 0.0]])
    Q = np.array([
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, q_F]]) * Parametros_2.dt
    R = np.array([[r_F]])  # varianza del sensor


    


class Modelo1:
    # Varianza de la tasa de cambio de u(t)
    q_u = 0.1
    # Varianza en las mediciones del sensor
    r_u = 0.039

    A = np.array([
        [-1/Parametros_1.k_s, Parametros_1.k_s/Parametros_1.tau],
        [0, 0]
    ])

    F = np.eye(2) + A *Parametros_1.dt
    H = np.array([[1.0, 0.0]])
    Q = np.array([
        [0, 0],
        [0, q_u * Parametros_1.dt]
    ])
    R = np.array([[r_u]])

    P0 = np.eye(2) * 0.001  # Covarianza inicial


if __name__ == "__main__":
    

    

    ##################################################################
    ###################### MODELO PRIMER ORDEN #######################
    ##################################################################


    kf_1 = KalmanFilter2(
        Modelo1.F,
        Modelo1.H,
        Modelo1.Q,
        Modelo1.R,
        Modelo1.P0
    )

    x1_kalman_1 = []
    u_kalman = []
    


    for i in range(len(tiempo_1)):
        z = x1_modelo1[i]

        kf_1.predict()
        kf_1.update(np.array([[z]]))


        x1_kalman_1.append(kf_1.x[0, 0])
        u_kalman.append([1, 0])

    u_fourier = fourier_1(x1_modelo1)

    

    plt.plot(tiempo_1, u_1, label='u(t) ideal')
    plt.plot(tiempo_1, u_fourier, label='u(t) fourier', alpha=0.5)
    # plt.ylim(-20, 20)
    plt.xlabel('Tiempo (s)')
    plt.ylabel('Respuesta')
    plt.title('Estimacion de u(t) modelo 1 con Fourier')
    plt.legend()
    plt.grid()
    plt.savefig('estimacion_u_fourier_modelo_1.png')
    plt.show()

    
    plt.plot(tiempo_1, u_1, label='u(t) ideal')
    plt.plot(tiempo_1, u_kalman, label='u(t) kalman')
    plt.ylim(-10, 10)
    plt.xlabel('Tiempo (s)')
    plt.ylabel('Respuesta')
    plt.title('Estimacion de u(t) modelo 1 con Kalman')
    plt.legend()
    plt.grid()
    plt.savefig('estimacion_u_kalman_modelo_1.png')
    plt.show()
    plt.figure()


    ##################################################################
    ####################### MODELO SEGUNDO ORDEN #####################
    ##################################################################

    #######################################
    ########## KALMAN #####################
    kf_2 = KalmanFilter3(
        Modelo2.F,
        Modelo2.H,
        Modelo2.Q,
        Modelo2.R,
        Modelo2.P0)

    x1_kalman_2 = []
    x2_kalman_2 = []
    fuerza_kalman = []
    
    for i in range(len(tiempo_2)):

        z = x1_modelo2[i] #+ np.random.normal(0, Modelo2.r_F ** (1/2))

        kf_2.predict() # Paso de prediccion
        kf_2.update(np.array([[z]])) # z debe ser un vector columna y representa la meedicion de x1(t)


        x1_kalman_2.append(kf_2.x[0, 0]) # x1 estimado 
        x2_kalman_2.append(kf_2.x[1, 0]) # x2 estimado
        fuerza_kalman.append(kf_2.x[2,0])

    #######################################
    ############ FOURIER ##################

    fuerza_fourier = fourier_2(x1_modelo2)


    plt.plot(tiempo_2, fuerza_kalman, label='F(t) kalman')
    plt.plot(tiempo_2, fuerza_2, label='F(t) ideal')
    plt.ylim(-10, 10)
    plt.title('Estimacion de F(t) modelo 2 con Kalman')
    plt.xlabel('Tiempo (s)')
    plt.ylabel('Respuesta')
    plt.legend()
    plt.grid()
    plt.savefig('estimacion_f_modelo_2.png')
    plt.show()


    plt.plot(tiempo_2, fuerza_2, label='F(t) ideal')
    plt.plot(tiempo_2, fuerza_fourier, label='F(t) Fourier', alpha=0.5)
    plt.ylim(-50, 50)
    plt.xlabel('Tiempo (s)')
    plt.title('Estimacion de F(t) modelo 2 con Fourier')
    plt.ylabel('Respuesta')
    plt.legend()
    plt.grid()
    plt.savefig('estimacion_f_fourier_modelo_2.png')
    plt.show()


    
    ########################################
    ############### ERRORES ################

    error_kalman_1 = np.array(u_1) - np.array(u_kalman)
    error_kalman_2 = np.array(fuerza_2) - np.array(fuerza_kalman)
    error_fourier_1 = np.array(u_1) - np.array(u_fourier)
    error_fourier_2 = np.array(fuerza_2) - np.array(fuerza_fourier)

    # Elevan al cuadrado los errores
    error_kalman_1 = np.square(error_kalman_1)
    error_kalman_2 = np.square(error_kalman_2)
    error_fourier_1 = np.square(error_fourier_1)
    error_fourier_2 = np.square(error_fourier_2)

    print("Error cuadratico medio modelo 1 (Kalman):", np.mean(error_kalman_1))
    print("Error cuadratico medio modelo 2 (Kalman):", np.mean(error_kalman_2))
    print("Error cuadratico medio modelo 1 (Fourier):", np.mean(error_fourier_1))
    print("Error cuadratico medio modelo 2 (Fourier):", np.mean(error_fourier_2))






































import numpy as np
import matplotlib.pyplot as plt


# def generar_fuerza_2(tiempo):
#     fuerza = []
#     for t in tiempo:
#         perfiles = [1/3, 0, 1/3, 0, 1/6, 0, -5/18, -5/18, -5/18, -5/18]
#         fuerza.append(perfiles[min(t // 600, len(perfiles)-1)])
#     return np.array(fuerza)

def generar_fuerza(tiempo, amplitud, freq, ruido = 0.02):

    return amplitud * np.sin(2 * np.pi * freq * tiempo) #+ np.random.normal(0.0, ruido,len(tiempo))

def generar_u(tiempo, amplitud, freq, ruido= 0.02):
    return amplitud * np.sin(2 * np.pi * freq * tiempo) + np.random.normal(0.0, ruido,len(tiempo))

class SegundoOrden:
    def __init__(self, omega_n, zeta, Ks, masa, dt):
        self.omega_n = omega_n
        self.zeta = zeta
        self.Ks = Ks
        self.masa = masa
        self.dt = dt
        self.x1 = 0.0 # y(t)
        self.x2 = 0.0 # dy(t)/dt

    def Actualizar(self, fuerza):

        x1 = self.x1 + self.dt * self.x2
        x2 = self.x2 + self.dt * (-(self.omega_n ** 2) * self.x1 - 2 * self.zeta * self.omega_n * self.x2 + self.Ks * fuerza / self.masa)

        # Actualiza
        self.x1 = x1
        self.x2 = x2

        return x1, x2
    
class PrimerOrden:
    def __init__(self, tau, k_s, dt):
        self.tau = tau
        self.k_s = k_s
        self.dt = dt
        self.x1 = 0.0

    
    def actualizar(self, u):
        x1 = self.x1 + self.dt * ( self.k_s * u -self.x1)/ self.tau
        # Actualiza
        self.x1 = x1

        return self.x1
    


class Parametros_2:
    omega_n = 2.0
    zeta = 0.01
    k_s = 4.0
    masa = 1.0
    
    amplitud = 0.8
    freq = 0.5

    dt = 0.01
    Tmax =10
    muestras = int(Tmax / dt)


class Parametros_1:
    tau = 1.0
    k_s = 1.0

    amplitud= 0.8
    freq = 0.5

    dt = 0.01
    Tmax =20
    muestras = int(Tmax / dt)



#######################################################################
####################### MODELO PRIMER ORDEN ###########################
#######################################################################

tiempo_1 = np.linspace(0, Parametros_1.Tmax, Parametros_1.muestras + 1)
u_1 = generar_u(tiempo_1, Parametros_1.amplitud, Parametros_1.freq)

x1_modelo1 = []

# Aplicar la entrada al modelo de primer orden
modelo_1 = PrimerOrden(Parametros_1.tau, Parametros_1.k_s, Parametros_1.dt)

for u in u_1:
    x1 = modelo_1.actualizar(u)
    x1_modelo1.append(x1)


plt.figure()
plt.plot(tiempo_1, u_1, label='u(t)')
plt.plot(tiempo_1, x1_modelo1, label='x1(t)=y(t)')
plt.title('Modelo de Primer Orden')
plt.xlabel('Tiempo (s)')
plt.ylabel('Respuesta')
plt.legend()
plt.grid()
plt.savefig('primer_orden.png')
plt.show()


#######################################################################
######################## MODELO SEGUNDO ORDEN #########################
#######################################################################

tiempo_2 = np.linspace(0, Parametros_2.Tmax, Parametros_2.muestras + 1)
fuerza_2 = generar_fuerza(tiempo_2, Parametros_2.amplitud, Parametros_2.freq)
#fuerza_2 = generar_fuerza_2(tiempo_2)

# Estado inicial
x1_modelo2 = []
x2_modelo2 = []

# Aplicar la entrada al modelo de segundo orden
modelo_2 = SegundoOrden(Parametros_2.omega_n, Parametros_2.zeta, Parametros_2.k_s, Parametros_2.masa, Parametros_2.dt)

for fz in fuerza_2:
    x1, x2 = modelo_2.Actualizar(fz)
    x1_modelo2.append(x1)
    x2_modelo2.append(x2)

plt.figure()
plt.plot(tiempo_2, fuerza_2, label='Fuerza')
plt.plot(tiempo_2, x1_modelo2, label='x1(t)=y(t)')
#plt.plot(tiempo_2, x2_modelo2, label='x2(t)', color='limegreen')
plt.title('Modelo de Segundo Orden')
plt.xlabel('Tiempo (s)')
plt.ylabel('Respuesta')
plt.legend()
plt.grid()
plt.savefig('segundo_orden.png')
plt.show()

#######################################################################
########################  ACONDICIONAMIENTO   #########################
#######################################################################

# def escalar(signal, min_sim, max_sim):
#     # Escala la señal simulada al rango de [-10 V, 10 V]
#     return 20.0 * (np.array(signal) - min_sim) / (max_sim - min_sim) - 10.0

def cuantizar(signal_esc, bits=8, rango_total=20.0):
    niveles = 2 ** bits
    paso = rango_total / niveles  # 20V / 256 0.078125 V
    return np.round(signal_esc / paso) * paso


# Cuantización 8 bits
#x1_modelo2 = cuantizar(escalar(x1_modelo2_original, min(x1_modelo2_original), max(x1_modelo2_original)), bits=8, rango_total=20.0)
x1_modelo2 = cuantizar(np.array(x1_modelo2))

x1_modelo1 = cuantizar(np.array(x1_modelo1))

#x1_modelo1 = cuantizar(escalar(x1_modelo1_original, min(x1_modelo1_original), max(x1_modelo1_original)), bits=8, rango_total=20.0)


# Graficar comparación
plt.figure()
plt.plot(tiempo_1, x1_modelo1, label='Original (Simulada)')
plt.plot(tiempo_1, x1_modelo1, '--', label='Escalada y Cuantizada (±10V, 8 bits)')
plt.title('Señal simulada vs acondicionada para DAQ ±10V modelo 2orden')
plt.xlabel('Tiempo (s)')
plt.ylabel('Voltaje (V)')
plt.legend()
plt.grid()
plt.show()



# Graficar comparación
plt.figure()
plt.plot(tiempo_2, x1_modelo2, label='Original (Simulada)')
plt.plot(tiempo_2, x1_modelo2, '--', label='Escalada y Cuantizada (±10V, 8 bits)')
plt.title('Señal simulada vs acondicionada para DAQ ±10V modelo 2orden')
plt.xlabel('Tiempo (s)')
plt.ylabel('Voltaje (V)')
plt.legend()
plt.grid()
plt.show()
